use clap::{Parser, Subcommand};
use std::collections::HashMap;
use rand::seq::SliceRandom;
use std::io::{Read, Write};
use std::path::PathBuf;
use serde_json as sj;
use rand::thread_rng;
use std::fs::File;
use csv;


#[derive(Parser)]
#[command(version)]
struct Args {
    #[command(subcommand)]
    command: Commands
}


#[derive(Subcommand)]
enum Commands {
    /// Generate a habilitation report
    Create {
        /// CSV file of the STUDIS grades
        studis_csv_filepath: PathBuf,
        /// JSON file of the possible responses per category per grade.
        response_json_filepath: PathBuf,
        /// Path to the output LaTeX file.
        output_filepath: PathBuf
    }
}


/// Preprocesses a CSV file exported from STUDIS. The result is a mapping, mapping different sections (as keys)
/// to CSV-compatible tables, which can be parsed by the csv crate.
fn preprocess_candidate_csv(filedata: String) -> HashMap<String, String> {   
    enum CSVParsingState {
        Header = 0,
        Columns
    }

    /// Replaces '\t' with commas and fixes the numbers to be separated by '.' instead of ','.
    fn fix_content(lines: &Vec<&str>) -> String {
        let mut olines = Vec::with_capacity(lines.len());
        let mut line_out;
        let mut split_i;
        for line in lines {
            split_i = line.find("\t").unwrap();
            line_out = (format!("\"{}\"", &line[..split_i]) + &line[split_i..].replace(",", ".")).replace("\t", ",");
            olines.push(line_out);
        }
        olines.join("\n")
    }

    let mut map = HashMap::new();
    let mut state = CSVParsingState::Header;
    let mut key= String::new();
    let mut key_data = Vec::new();
    for line in filedata.lines() {
        match state {
            CSVParsingState::Header => {
                key = String::from(line.trim());
                key_data.clear();
                state = CSVParsingState::Columns;
            }
            CSVParsingState::Columns => {
                if line.trim() == "" {  // Empty line
                    map.insert(key.clone(), fix_content(&key_data));
                    state = CSVParsingState::Header;
                }
                key_data.push(line);
            }
        }
    }

    if let CSVParsingState::Columns = state {  // In case there was no new empty line
        map.insert(key.clone(), fix_content(&key_data));
    }

    map
}


fn command_create(studis_csv_filepath: &PathBuf, response_json_filepath: &PathBuf, output_filepath: &PathBuf) {
    const E_NOT_MAPPING: &str = "Not a JSON mapping";

    const C_GRADES_KEY: &str = "Anketa o izvajalcu";
    const C_MEAN_CSV_KEY: &str = "Povprečje";
    const C_STD_CSV_KEY: &str = "Standardni odklon";
    const C_JSON_MAP_QUESTION_KEY: &str = "Vprašanje";

    const C_OUTPUT_LATEX_REPLACE_KEY: &str = "{AUTO_GEN}";

    // Check the output file
    let mut output_fdata: String = String::new();
    let mut output_parts = Vec::new();
    let mut output_file = File::open(output_filepath).unwrap();
    output_file.read_to_string(&mut output_fdata).unwrap();
    output_file = File::options().write(true).open(output_filepath).unwrap();

    if !output_fdata.contains(C_OUTPUT_LATEX_REPLACE_KEY) {
        panic!(
            "output file ({output_filepath:?}) does not mark the location \
            of automatically-generated content (generated by this script). Mark it by writing \
            \"{C_OUTPUT_LATEX_REPLACE_KEY}\" somewhere in the file"
        );
    }

    // Variables for opening input files
    let mut file: File;
    let mut fdata= String::new();

    // Process CSV file. This is the file exported from STUDIS
    file = File::open(studis_csv_filepath).unwrap();
    file.read_to_string(&mut fdata).unwrap();
    let preprocessed = preprocess_candidate_csv(fdata);
    let csvgrades: &String = preprocessed.get(C_GRADES_KEY)
        .expect(&format!("could not find key \"{C_GRADES_KEY}\" in {studis_csv_filepath:?} ({:?})", preprocessed.keys()));
    
    let mut csvgrades = csv::Reader::from_reader(csvgrades.as_bytes());
    let headers = csvgrades.headers().unwrap().clone();
    let records: Vec<Vec<String>> = csvgrades.records()
        .map(|x| x.unwrap().iter().map(|x| x.to_string()).collect()).collect();

    let mut csvgrades = HashMap::new();
    for (c, header) in headers.iter().enumerate() {
        let mut column_data = Vec::new();
        for record in &records {
            column_data.push(record[c].clone());
        }
        csvgrades.insert(header, column_data);
    }

    // Process JSON file. This is the file containing responses for each category and each grade.
    file = File::open(response_json_filepath).unwrap();   
    let json_map: sj::Map<_, _> = sj::from_reader(file).expect(E_NOT_MAPPING);
    let categories: &sj::Map<_, _> = &json_map[C_JSON_MAP_QUESTION_KEY].as_object().expect(E_NOT_MAPPING);
    let mut idx: usize;
    let mut start_size: usize;
    let mut mean: f64;
    let mut std: f64;
    let mut rgn = thread_rng();

    // Iterate each category/question of the JSON responses file
    for (cat, grades_json) in categories {
        // Get index of the question matching JSON category
        idx = csvgrades.get(C_JSON_MAP_QUESTION_KEY).expect("CSV is missing questions key.")
            .iter().position(|x| x == cat).expect(&format!("CSV is missing category \"{cat}\""));
        mean = csvgrades.get(C_MEAN_CSV_KEY).expect("CSV is missing the mean grade value key")[idx].parse().unwrap();
        std = csvgrades.get(C_STD_CSV_KEY).expect("CSV is missing the std of grade key")[idx].parse().unwrap();

        // Obtain the mapping of min. grade => array of String responses
        let grades_json = grades_json.as_object().cloned().expect(E_NOT_MAPPING);
        let mut grades: Vec<(&String, f64)> = grades_json.keys().map(
            // Save grades in format (String (original), parsed float)
            |x| (x, x.parse().expect(&format!("grades must be floats (\"{x}\")")))
        ).collect();

        // Sort the grades by the parsed value
        grades.sort_by(|(_, a), (_, b)| b.total_cmp(a));

        // Iterate sorted keys from largest grade to lowest, compare each parsed grade to the mean value of CSV grades
        // and stop when we find the key that is lower or equal than the mean.
        start_size = output_parts.len();
        for (sgrade, grade) in grades.iter() {
            if (grade * 10000.0) as usize <= (mean * 10000.0) as usize {  // Prevent influence of numeric error
                let v = grades_json.get(*sgrade).unwrap();
                let response = v.as_array()
                    .expect(&format!("value of Category->Grade->Value must be an array of strings. Found {v:?}"))
                    .choose(&mut rgn)
                    .expect(&format!("there are no defined responses for grade {sgrade}, category {cat:?}"));
                let response = response.as_str().expect(&format!("responses must be strings ({response} is not)"));
                output_parts.push(format!("% {cat} ({mean} +- {std})\n{response}"));
                break;
            }
        }

        // Check if loop was not break-ed;
        if start_size == output_parts.len() {
            panic!("could not find grade below mean ({mean}) for category \"{cat}\"");
        }
    }

    // Write output file
    output_fdata = output_fdata.replace(C_OUTPUT_LATEX_REPLACE_KEY, &(output_parts.join("\n\n")));
    output_file.write_all(output_fdata.as_bytes()).unwrap();
}


fn main() {
    let cli = Args::parse();

    match &cli.command {
        Commands::Create { studis_csv_filepath, response_json_filepath, output_filepath } => {
            command_create(studis_csv_filepath, response_json_filepath, output_filepath);
        }
    }
    // command_create(&PathBuf::from("ocena.csv"), &PathBuf::from("mnenje.json"), &PathBuf::from("mnenje.tex"));
}
